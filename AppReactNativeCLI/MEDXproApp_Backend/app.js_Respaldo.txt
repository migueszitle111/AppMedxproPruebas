
const express=require("express");
const app=express();
const mongoose=require("mongoose");
app.use(express.json());
const bcrypt=require("bcrypt");
const jwt=require("jsonwebtoken");
require('dotenv').config();
const upload = require('./upload');
const path=require("path");
const nodemailer = require('nodemailer');
const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(); // sin clientId si solo verificas
const cors = require('cors');
const { google } = require('googleapis');

app.use(cors()); // <- Permite cualquier origen

const PORT = process.env.PORT || 5001;

const mongoUrl= process.env.MONGO_URL;
const WEB_CLIENT_ID = process.env.WEB_CLIENT_ID;
const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;

const JWT_SECRET = process.env.JWT_SECRET;

mongoose.
    connect(mongoUrl)
    .then(()=>{
        console.log("Conectado a la base de datos");
    })
    .catch((error)=>{
        console.log(error);
    });
require('./UserDetails');
const User=mongoose.model("UserInfo");

app.get("/",(req,res)=>{
    res.send({status:"Comenzando el servidor"});
});

app.use('/uploads', express.static(path.join(__dirname, 'uploads'))); // para servir im치genes

// 游릭 Configura nodemailer con Gmail
const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: process.env.SMTP_PORT,
    secure: true,
    //service: 'gmail',
    auth: {
      user: process.env.SMTP_USER,           // Cambia esto por tu correo real
      pass: process.env.SMTP_PASS,
    },
});

// Configura Google API con cuenta de servicio
const key = require("./google-service-key.json"); // 丘멆잺 aseg칰rate de poner tu JSON de service account aqu칤
const auth = new google.auth.GoogleAuth({
  credentials: key,
  scopes: ["https://www.googleapis.com/auth/androidpublisher"],
});
const playDeveloperApi = google.androidpublisher({ version: "v3", auth });

app.post("/registrar", upload.single('image'), async (req,res)=>{
    const {name,lastname,idprofessional,specialty,email,password,roles} = req.body;

    const OldUser = await User.findOne({email:email});

    if(OldUser){
        return res.send({status:"Error", data: "El usuario ya existe"});
    }

    const encryptPassword = await bcrypt.hash(password, 10);
    const imageUrl = req.file ? `https://${req.headers.host}/uploads/${req.file.filename}` : '';

    try {
        await User.create({
            name: name,
            lastname: lastname,
            idprofessional,
            specialty,
            email: email,
            password: encryptPassword,
            //roles,
            imageUrl
        });

        // 游릭 Enviar correo de bienvenida
        const mailOptions = {
            from: process.env.SMTP_FROM,
            to: email,
            subject: 'Bienvenido a MEDXpro',
            html: `
            <h1>춰Hola ${name}!</h1>
            <p>Gracias por registrarte en <strong>MEDXpro</strong>.</p>
            <p>Tu cuenta ha sido creada exitosamente con el correo: <b>${email}</b>.</p>
            `,
        };

        transporter.sendMail(mailOptions, (error, info) => {
            if (error) {
                console.error('Error al enviar el correo de bienvenida:', error);
            } else {
                console.log('Correo enviado:', info.response);
            }
        });

        res.send({status:"OK", data: "Usuario registrado"});
    } catch (error) {
        res.send({status:"Error", data: error});
    }
});


/*const main = async () => {
    const password = "Adrian*123";
    const hash = await bcrypt.hash(password, 10);
    console.log("Hash generado para Adrian*123:", hash);
  };
  
  main();*/

app.post("/login", async (req,res)=>{
    console.log('Petici칩n recibida:', req.body);
    const {email,password} = req.body;
    const OldUser = await User.findOne({email:email});

    if(!OldUser){
        return res.send({status:"Error", data: "El usuario no existe"});
    }

    const isPasswordValid = await bcrypt.compare(password,OldUser.password);

    console.log('Password comparado:', isPasswordValid); // <- Agregado
    console.log('Password enviado:', password);
    console.log('Password en BD:', OldUser.password);

    if(isPasswordValid){
        const token = jwt.sign({
            email:OldUser.email,
        },JWT_SECRET);

        return res.status(200).send({status:"ok", data: token});
    }else{
        return res.send({status:"Error", data: "La contrase침a es incorrecta"});
    }
    /*if(await bcrypt.compare(password,OldUser.password)){
        const token = jwt.sign({
            email:OldUser.email,
        },JWT_SECRET);

        if(res.status(201)){
            return res.send({status:"ok", data: token});
        }else{
            return res.send({error:"error"});
        }
    }*/
})

app.post("/login-google", async (req, res) => {
    console.log('Petici칩n recibida:', req.body);
    const { idToken } = req.body;

    if (!idToken) {
        return res.status(400).send({ status: "Error", data: "Falta el idToken" });
    }

    try {
        const ticket = await client.verifyIdToken({
            idToken,
            audience: WEB_CLIENT_ID, // <<--- IMPORTANTE: agrega tu client ID aqu칤
        });

        const payload = ticket.getPayload();
        const email = payload.email;
        const name = payload.name || 'Usuario Google';
        const picture = payload.picture || '';

        let user = await User.findOne({ email });

        if (!user) {
            user = await User.create({
                name,
                lastname: null,
                idprofessional: null,
                specialty: null,
                email,
                password: null,
                //roles: 'usuario',
                imageUrl: picture,
            });

            console.log("Nuevo usuario creado:", user);

            const mailOptions = {
                from: process.env.SMTP_FROM,
                to: email,
                subject: 'Bienvenido a MEDXpro',
                html: `
                <h1>춰Hola ${name}!</h1>
                <p>Gracias por registrarte en <strong>MEDXpro</strong> en Google.</p>
                <p>Tu cuenta ha sido creada exitosamente con el correo: <b>${email}</b>.</p>
                `,
            };
            
            transporter.sendMail(mailOptions, (error, info) => {
                if (error) {
                    console.error('Error al enviar el correo de bienvenida:', error);
                } else {
                    console.log('Correo enviado:', info.response);
                }
            });
        } else {
            console.log("Usuario encontrado:", user);
        }

        const token = jwt.sign({ email: user.email }, JWT_SECRET);
        return res.status(200).send({ status: "ok", data: token });

    } catch (error) {
        console.error("Error al verificar idToken:", error);
        return res.status(401).send({ status: "Error", data: "Token inv치lido" });
    }
});

app.post("/reset-password", async (req, res) => {
    const { email, newPassword } = req.body;

    if (!email || !newPassword) {
        return res.send({ status: "Error", data: "Campos incompletos" });
    }

    const user = await User.findOne({ email });

    if (!user) {
        return res.send({ status: "Error", data: "El usuario no existe" });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);

    try {
        await User.updateOne({ email }, { $set: { password: hashedPassword } });
        return res.send({ status: "OK", data: "Contrase침a actualizada correctamente" });
    } catch (error) {
        console.error("Error al actualizar contrase침a:", error);
        return res.send({ status: "Error", data: "Error al actualizar la contrase침a" });
    }
});  

app.post("/userdata",async (req,res)=>{
    console.log('Petici칩n recibida UserData:', req.body);
    const {token} = req.body;
    try {
        const user = jwt.verify(token,JWT_SECRET);
        const useremail = user.email;
        
        User.findOne({ email: useremail}).then((data)=> {
            return res.send({status:"OK", data:data});
        });
    } catch (error) {
        res.send({error: error});
    }    
});

app.put("/userdataUpdate", upload.single('image'), async (req,res)=>{
    const {token} = req.body;

    try {
        const decoded = jwt.verify(token,JWT_SECRET);
        const email = decoded.email;

        const updateData = {
            name: req.body.name,
            lastname: req.body.lastname,
            idprofessional: req.body.idprofessional,
            specialty: req.body.specialty,
            //roles: req.body.roles,
        };

        if (req.file) {
            updateData.imageUrl = `https://${req.headers.host}/uploads/${req.file.filename}`;
            console.log("URL de la imagen actualizada:",updateData.imageUrl);
        }

        //Si hay nueva contrase침a, encriptar
        if (req.body.password && req.body.password.trim() !== '') {
            updateData.password = await bcrypt.hash(req.body.password, 10);
        }

        const updateUser = await User.findOneAndUpdate(
            {email: email},
            updateData,
            {new: true}
        );

        res.send({ status: "OK", data: updateUser});
    } catch (error) {
        console.error(error);
        res.send({status:"Error", data: "Error al actualizar el usuario"});
    }
});

app.post("/verify-subscription", async (req, res) => {
    const { token, purchaseToken, productId } = req.body;
  
    if (!token || !purchaseToken || !productId) {
      return res.status(400).send({ status: "Error", data: "Datos faltantes" });
    }
  
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      const email = decoded.email;
  
      // 丘멆잺 Usa el packageName EXACTO de tu app en Play Console
      const packageName = "com.tu.app"; 
  
      // Llamar a la API de Google Play
      const response = await playDeveloperApi.purchases.subscriptions.get({
        packageName,
        subscriptionId: productId,
        token: purchaseToken,
      });
  
      const data = response.data;
      console.log("Respuesta Google Play:", data);
  
      // Guardar suscripci칩n dentro del usuario
      const updatedUser = await User.findOneAndUpdate(
        { email },
        {
          $set: {
            subscription: {
              productId,
              purchaseToken,
              startDate: data.startTimeMillis ? new Date(Number(data.startTimeMillis)) : null,
              expiryDate: data.expiryTimeMillis ? new Date(Number(data.expiryTimeMillis)) : null,
              valid: data.paymentState === 1, // 1 = PAGADO
            }
          }
        },
        { new: true }
      );
  
      if (!updatedUser) {
        return res.status(404).send({ status: "Error", data: "Usuario no encontrado" });
      }
  
      res.send({ status: "OK", data: updatedUser.subscription });
    } catch (err) {
      console.error("Error al verificar suscripci칩n:", err);
      res.status(500).send({ status: "Error", data: "Fallo al verificar" });
    }
  });

app.delete("/deleteUser", async (req, res) => {
    console.log('Petici칩n recibida:', req.body);
    const { token } = req.body;

    if (!token) {
        return res.status(400).send({ status: "Error", data: "Token faltante" });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const email = decoded.email;

        const deletedUser = await User.findOneAndDelete({ email });

        if (!deletedUser) {
            return res.status(404).send({ status: "Error", data: "Usuario no encontrado" });
        }

        return res.send({ status: "OK", data: "Cuenta eliminada correctamente" });
    } catch (error) {
        console.error("Error al eliminar cuenta:", error);
        return res.status(500).send({ status: "Error", data: "Error al eliminar cuenta" });
    }
});

app.listen(PORT,()=>{
    console.log(`El servidor(NodeJs) est치 corriendo en el puerto ${PORT}`);
})

:::::::::::::::::::::::::::::......
Version1
___________________________________-

const express=require("express");
const app=express();
const mongoose=require("mongoose");
app.use(express.json());
const bcrypt=require("bcrypt");
const jwt=require("jsonwebtoken");
require('dotenv').config();
const upload = require('./upload');
const path=require("path");
const nodemailer = require('nodemailer');
const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(); // sin clientId si solo verificas


const PORT = 5001;

const mongoUrl= process.env.MONGO_URL;
const WEB_CLIENT_ID = process.env.WEB_CLIENT_ID;

const JWT_SECRET="hvdvay6ert72839289()aiyg8josdks90902132kjs09[]]jk89sd";

mongoose.
    connect(mongoUrl)
    .then(()=>{
        console.log("Conectado a la base de datos");
    })
    .catch((error)=>{
        console.log(error);
    });
require('./UserDetails');
const User=mongoose.model("UserInfo");

app.get("/",(req,res)=>{
    res.send({status:"Comenzando el servidor"});
});

app.use('/uploads', express.static(path.join(__dirname, 'uploads'))); // para servir im치genes

// 游릭 Configura nodemailer con Gmail
const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: 'medxproresidencia@gmail.com',           // Cambia esto por tu correo real
      pass: process.env.GMAIL_APP_PASSWORD,//'srdz mjxf xdek vcsj' // Usa una "contrase침a de aplicaci칩n" si usas Gmail
    },
});

app.post("/registrar", upload.single('image'), async (req,res)=>{
    const {name,lastname,idprofessional,specialty,email,password,roles} = req.body;

    const OldUser = await User.findOne({email:email});

    if(OldUser){
        return res.send({status:"Error", data: "El usuario ya existe"});
    }

    const encryptPassword = await bcrypt.hash(password, 10);
    const imageUrl = req.file ? `http://192.168.0.10:5001/uploads/${req.file.filename}` : '';

    try {
        await User.create({
            name: name,
            lastname: lastname,
            idprofessional,
            specialty,
            email: email,
            password: encryptPassword,
            roles,
            imageUrl
        });

        // 游릭 Enviar correo de bienvenida
        const mailOptions = {
            from: 'medxproresidencia@gmail.com',
            to: email,
            subject: 'Bienvenido a MEDXpro',
            html: `
            <h1>춰Hola ${name}!</h1>
            <p>Gracias por registrarte en <strong>MEDXpro</strong>.</p>
            <p>Tu cuenta ha sido creada exitosamente con el correo: <b>${email}</b>.</p>
            `,
        };

        transporter.sendMail(mailOptions, (error, info) => {
            if (error) {
                console.error('Error al enviar el correo de bienvenida:', error);
            } else {
                console.log('Correo enviado:', info.response);
            }
        });

        res.send({status:"OK", data: "Usuario registrado"});
    } catch (error) {
        res.send({status:"Error", data: error});
    }
});


const main = async () => {
    const password = "Adrian*123";
    const hash = await bcrypt.hash(password, 10);
    console.log("Hash generado para Adrian*123:", hash);
  };
  
  main();

app.post("/login", async (req,res)=>{
    console.log('Petici칩n recibida:', req.body);
    const {email,password} = req.body;
    const OldUser = await User.findOne({email:email});

    if(!OldUser){
        return res.send({status:"Error", data: "El usuario no existe"});
    }

    const isPasswordValid = await bcrypt.compare(password,OldUser.password);

    console.log('Password comparado:', isPasswordValid); // <- Agregado
    console.log('Password enviado:', password);
    console.log('Password en BD:', OldUser.password);

    if(isPasswordValid){
        const token = jwt.sign({
            email:OldUser.email,
        },JWT_SECRET);

        return res.status(200).send({status:"ok", data: token});
    }else{
        return res.send({status:"Error", data: "La contrase침a es incorrecta"});
    }
    /*if(await bcrypt.compare(password,OldUser.password)){
        const token = jwt.sign({
            email:OldUser.email,
        },JWT_SECRET);

        if(res.status(201)){
            return res.send({status:"ok", data: token});
        }else{
            return res.send({error:"error"});
        }
    }*/
})

app.post("/login-google", async (req, res) => {
    console.log('Petici칩n recibida:', req.body);
    const { idToken } = req.body;

    if (!idToken) {
        return res.status(400).send({ status: "Error", data: "Falta el idToken" });
    }

    try {
        const ticket = await client.verifyIdToken({
            idToken,
            audience: WEB_CLIENT_ID, // <<--- IMPORTANTE: agrega tu client ID aqu칤
        });

        const payload = ticket.getPayload();
        const email = payload.email;
        const name = payload.name || 'Usuario Google';
        const picture = payload.picture || '';

        let user = await User.findOne({ email });

        if (!user) {
            user = await User.create({
                name,
                lastname: '.',
                idprofessional: '.',
                specialty: '.',
                email,
                password: '.',
                roles: 'usuario',
                imageUrl: picture,
            });

            console.log("Nuevo usuario creado:", user);

            const mailOptions = {
                from: 'medxproresidencia@gmail.com',
                to: email,
                subject: 'Bienvenido a MEDXpro',
                html: `
                <h1>춰Hola ${name}!</h1>
                <p>Gracias por registrarte en <strong>MEDXpro</strong> en Google.</p>
                <p>Tu cuenta ha sido creada exitosamente con el correo: <b>${email}</b>.</p>
                `,
            };
            
            transporter.sendMail(mailOptions, (error, info) => {
                if (error) {
                    console.error('Error al enviar el correo de bienvenida:', error);
                } else {
                    console.log('Correo enviado:', info.response);
                }
            });
        } else {
            console.log("Usuario encontrado:", user);
        }

        const token = jwt.sign({ email: user.email }, JWT_SECRET);
        return res.status(200).send({ status: "ok", data: token });

    } catch (error) {
        console.error("Error al verificar idToken:", error);
        return res.status(401).send({ status: "Error", data: "Token inv치lido" });
    }
});

app.post("/reset-password", async (req, res) => {
    const { email, newPassword } = req.body;

    if (!email || !newPassword) {
        return res.send({ status: "Error", data: "Campos incompletos" });
    }

    const user = await User.findOne({ email });

    if (!user) {
        return res.send({ status: "Error", data: "El usuario no existe" });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);

    try {
        await User.updateOne({ email }, { $set: { password: hashedPassword } });
        return res.send({ status: "OK", data: "Contrase침a actualizada correctamente" });
    } catch (error) {
        console.error("Error al actualizar contrase침a:", error);
        return res.send({ status: "Error", data: "Error al actualizar la contrase침a" });
    }
});  

app.post("/userdata",async (req,res)=>{
    console.log('Petici칩n recibida UserData:', req.body);
    const {token} = req.body;
    try {
        const user = jwt.verify(token,JWT_SECRET);
        const useremail = user.email;
        
        User.findOne({ email: useremail}).then((data)=> {
            return res.send({status:"OK", data:data});
        });
    } catch (error) {
        res.send({error: error});
    }    
});

app.put("/userdataUpdate", upload.single('image'), async (req,res)=>{
    const {token} = req.body;

    try {
        const decoded = jwt.verify(token,JWT_SECRET);
        const email = decoded.email;

        const updateData = {
            name: req.body.name,
            lastname: req.body.lastname,
            idprofessional: req.body.idprofessional,
            specialty: req.body.specialty,
            roles: req.body.roles,
        };

        if (req.file) {
            updateData.imageUrl = `http://192.168.0.10:5001/uploads/${req.file.filename}`;
            console.log("URL de la imagen actualizada:",updateData.imageUrl);
        }

        //Si hay nueva contrase침a, encriptar
        if (req.body.password && req.body.password.trim() !== '') {
            updateData.password = await bcrypt.hash(req.body.password, 10);
        }

        const updateUser = await User.findOneAndUpdate(
            {email: email},
            updateData,
            {new: true}
        );

        res.send({ status: "OK", data: updateUser});
    } catch (error) {
        console.error(error);
        res.send({status:"Error", data: "Error al actualizar el usuario"});
    }
});

app.delete("/deleteUser", async (req, res) => {
    console.log('Petici칩n recibida:', req.body);
    const { token } = req.body;

    if (!token) {
        return res.status(400).send({ status: "Error", data: "Token faltante" });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const email = decoded.email;

        const deletedUser = await User.findOneAndDelete({ email });

        if (!deletedUser) {
            return res.status(404).send({ status: "Error", data: "Usuario no encontrado" });
        }

        return res.send({ status: "OK", data: "Cuenta eliminada correctamente" });
    } catch (error) {
        console.error("Error al eliminar cuenta:", error);
        return res.status(500).send({ status: "Error", data: "Error al eliminar cuenta" });
    }
});

app.listen(PORT,()=>{
    console.log(`El servidor(NodeJs) est치 corriendo en el puerto ${PORT}`);
})